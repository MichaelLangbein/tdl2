# Kubernetes

https://www.youtube.com/watch?v=X48VuDVv0do&t=365s

## Basic components

-   a _deployment_ manages a ...
-   _replica-set_, which manages ...
-   _pods_, which are an abstraction of ...
-   _containers_

<br/>

-   **node**:
    -   physical machine with own IP, hosts multiple pods
-   **pod**
    -   usually one container in one pod
    -   integrated virtual network: each pod has own IP
    -   ephemeral: a pod dies easily ... so replacement pod gets other IP
-   **deployment**
    -   abstraction over pods
    -   one or several pods from the same blueprint
    -   each pod inside deployment must be stateless (thus no db's)
-   **stateful set**
    -   a deployment that does allow state
    -   harder to set up, though! Often db's are actually managed services outside of k8s
-   **service**
    -   a static IP
    -   a deployment connected to that IP
    -   even if a pod dies, the service remains, IP attached to replacement
    -   internal service:
        -   only available inside
    -   external service:
        -   available to outside via host-node's IP and a port
    -   serves as load balancer: directs traffic to whichever node is least busy
-   **ingress**:
    -   forwards requests to services

<br/>

-   **ConfigMap**
    -   configuration data
    -   can be connected to pods
    -   don't put credentials in there! Thats what Secret is there for
-   **Secret**
    -   same as ConfigMap, but for credentials, certificates, keys, tokens
-

<br/>

-   **Volumes**
    -   can be node-local or elsewhere (even outside k8s-cluster in cloud)
    -   k8s doesn't do any replication or backups!

<br/>

## k8s internals

-   **master** nodes
    -   schedule pods, restart, monitor
    -   4 processes on every master node:
        -   API server (which also ensures authentication)
        -   scheduler: sends pods to some of the workers (preferring least busy nodes)
        -   Controller manager: detect pod crashes, tells scheduler to re-schedule pods
        -   etcd: key/value store of cluster state: who is current master, whats currently running, ...
            -   etcd distributed over all master-nodes
-   **slave**/worker nodes
    -   3 processes on every worker node:
        -   container runtime (docker)
        -   kubelet: takes config, starts containers, assigns resources
        -   kube proxy: forwards requests (prefers locally hosted pods where possible)

## minicube

## kubectl

-   minikube
    -   start
    -   stop

All CRUD operations should happen at the deployments-level. That is, except for debugging, you should never CRUD an individual pod - just edit the whole deployment instead.

-   kubectl
    -   get
        -   pod
        -   deployment
        -   services
        -   replicaset
        -   -o
            -   wide
            -   yaml
    -   create
        -   deployment <name> --image=<image-name> --dry-run
        -   service
    -   edit
        -   deployment <name>
        -   ...
    -   delete
        -   deployment <name>
        -   ...
    -   logs <podname, as obtained from `kubectl get pod`>
    -   describe
        -   service <name>
        -   <podname>
        -   ...
    -   exec -it <podname> -- bin/bash
    -   apply -f <config-file-name>.yaml

## YAML config file

### Single element definition:

-   3 parts
    -   metadata
    -   specification
    -   (status: auto-generated by k8s, as fetched from etcd)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
    name: nginx-deployment
spec:
    replicas: 2
    selector:
```

### Complete architecture definition:

```yaml

```

## Example: riesgos on k8s
