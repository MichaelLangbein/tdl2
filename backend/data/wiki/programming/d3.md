# D3


## Concept summaries

- d3 chains `selections`
- `selections` manage html/svg-`node`s.
- `selections` have methods that offer data to a `callback` and return another selection
    ```js
    calback: (datum, index, nodes) -> void
    selection.method(callback) -> selection
    ```
- Through calling those methods you can make the selection modify its `node`s.
    - If inside a `callback` you need to access the `selection`,  use `this` or `select(nodes[index])`
- a special method is `append`: here you can add `node`s directly
    - ... either as a string: `"g"`, or `"rect"`, ...
    - ... or by creating a custom node: 
        ```js
        const selection = create('svg:g'); 
        selection.doSth(); return selection.node();
        ```
- `layout`: modifies data to add information about its placement
- `generators`: take a datum and transform it into simple svg-element-node(s)
    ```js
    generator = closure((datum) => node[], methods)
    generator.method()
    selection.attr('d', generator)
    ```
- `components`: take a selection and modify it with more selecions
    ```js
    component = closure((selection) => void, methods)
    component.method()
    selection.call(component)
    ```

## Important concepts and misconceptions

- D3 is **not reactive**. A selection, once made, contains only the data that already existed at the time of construction.
  - When you add new data to a selection(`mySelection.data(newData)`), the `enter()` and `exit()` functions are not automatically executed again.
  - If you added a behavior to a selection and then add new elements to the selection, you'll have to add the behavior to those new elements again.
  - When a new element is added to a selection, that new node will not be visible if the selection is called upon again later.
    - ```js 
        bars.data(data, d => d.x)
            .enter()
            .each(createBar);
        console.log('old selection', bars)                      // <-- has no entries
        console.log('fresh selection', svg.selectAll('.bar'))   // <-- does have entries
        ```

Illustrative example application:
```js
import {select, create, forceCenter, forceLink, forceManyBody, forceSimulation, line, drag, easeBounce, event } from 'd3';


/****************************************************************
 *      Part 0: settings
 ****************************************************************/

const width = 600;
const height = 400;

// Primary color:
const shade0Primary = '#933157'; // = rgb(147, 49, 87) = rgba(147, 49, 87,1) = rgb0(0.576,0.192,0.341)
const shade1Primary = '#E9508B'; // = rgb(233, 80,139) = rgba(233, 80,139,1) = rgb0(0.914,0.314,0.545)
const shade2Primary = '#C54375'; // = rgb(197, 67,117) = rgba(197, 67,117,1) = rgb0(0.773,0.263,0.459)
const shade3Primary = '#612039'; // = rgb( 97, 32, 57) = rgba( 97, 32, 57,1) = rgb0(0.38,0.125,0.224)
const shade4Primary = '#2F0F1B'; // = rgb( 47, 15, 27) = rgba( 47, 15, 27,1) = rgb0(0.184,0.059,0.106)

// Secondary color (1):
const shade0Secondary1 = '#AA5039'; // = rgb(170, 80, 57) = rgba(170, 80, 57,1) = rgb0(0.667,0.314,0.224)
const shade1Secondary1 = '#FF7B58'; // = rgb(255,123, 88) = rgba(255,123, 88,1) = rgb0(1,0.482,0.345)
const shade2Secondary1 = '#E46D4D'; // = rgb(228,109, 77) = rgba(228,109, 77,1) = rgb0(0.894,0.427,0.302)
const shade3Secondary1 = '#703425'; // = rgb(112, 52, 37) = rgba(112, 52, 37,1) = rgb0(0.439,0.204,0.145)
const shade4Secondary1 = '#361911'; // = rgb( 54, 25, 17) = rgba( 54, 25, 17,1) = rgb0(0.212,0.098,0.067)

// Secondary color (2):
const shade0Secondary2 = '#28794C'; // = rgb( 40,121, 76) = rgba( 40,121, 76,1) = rgb0(0.157,0.475,0.298)
const shade1Secondary2 = '#48D083'; // = rgb( 72,208,131) = rgba( 72,208,131,1) = rgb0(0.282,0.816,0.514)
const shade2Secondary2 = '#37A266'; // = rgb( 55,162,102) = rgba( 55,162,102,1) = rgb0(0.216,0.635,0.4)
const shade3Secondary2 = '#1A5032'; // = rgb( 26, 80, 50) = rgba( 26, 80, 50,1) = rgb0(0.102,0.314,0.196)
const shade4Secondary2 = '#0C2718'; // = rgb( 12, 39, 24) = rgba( 12, 39, 24,1) = rgb0(0.047,0.153,0.094)

// Complement color:
const shade0Complement = '#6B9A33'; // = rgb(107,154, 51) = rgba(107,154, 51,1) = rgb0(0.42,0.604,0.2)
const shade1Complement = '#A7F053'; // = rgb(167,240, 83) = rgba(167,240, 83,1) = rgb0(0.655,0.941,0.325)
const shade2Complement = '#8FCF46'; // = rgb(143,207, 70) = rgba(143,207, 70,1) = rgb0(0.561,0.812,0.275)
const shade3Complement = '#466621'; // = rgb( 70,102, 33) = rgba( 70,102, 33,1) = rgb0(0.275,0.4,0.129)
const shade4Complement = '#223110'; // = rgb( 34, 49, 16) = rgba( 34, 49, 16,1) = rgb0(0.133,0.192,0.063)
//  Generated by Paletton.com (c) 2002-2014


/****************************************************************
 *      Part 1: data / state
 ****************************************************************/

let peopleCounter = 0;
let people = [];
let relationCounter = 0;
let relations = [];


/****************************************************************
 *      Part 2: selections
 ****************************************************************/

const base = select('#svg')
    .style('width', width).style('height', height)
    .append('g');

const bubbleSelector = '.bubble';
const lineSelector = '.line';
const dashedLineSelector = '.dashedLine';

const addNodeButton = document.getElementById('addNode');
addNodeButton.addEventListener('click', onAddNodeButtonClicked);

/****************************************************************
 *      Part 3: event handlers
 ****************************************************************/

 function onAddNodeButtonClicked() {
    const node = {
        id: peopleCounter,
        x: width * Math.random(),
        y: height * Math.random()
    };
    peopleCounter += 1;
    people.push(node);
    
    base.selectAll(bubbleSelector)
        .data(people, d => d.id)
        .enter()
            .each(createLabeledBubble);
}

const dragBehavior = drag()
    .filter((e) => !e.button)
    .on('start', (e, d) => e.sourceEvent.ctrlKey ? onConnectStart(e, d) : onDragStart(e, d) )
    .on('drag',  (e, d) => e.sourceEvent.ctrlKey ? onConnect(e, d)      : onDrag(e, d)      )
    .on('end',   (e, d) => e.sourceEvent.ctrlKey ? onConnectEnd(e, d)   : onDragEnd(e, d)   );


function onDragStart(evt, datum) {
}

function onDrag(evt, datum) {
    people.forEach(p => {
        if (p.id === datum.id) {
            p.x = evt.x;
            p.y = evt.y;
        }
    });

    base.selectAll(bubbleSelector)
        .data(people, d => d.id)
        .each(updateLabeledBubble);
    
    base.selectAll(lineSelector)
        .data(relations, d => d.id)
        .each(updateConnection);
}

function onDragEnd(evt, datum) {
}

function onConnectStart(evt, datum) {
    const d = {
        id: 0,
        source: datum,
        target: {
            x: evt.x,
            y: evt.y
        }
    };
    base.selectAll(dashedLineSelector)
        .data([d], d => d.id)
        .enter()
            .each(createDashedLine);
}

function onConnect(evt, datum) {
    const d = {
        id: 0,
        source: datum,
        target: {
            x: evt.x,
            y: evt.y
        }
    };
    base.selectAll(dashedLineSelector)
        .data([d], d => d.id)
            .each(updateDashedLine);
}

function onConnectEnd(evt, datum) {
    base.selectAll(dashedLineSelector)
        .data([], d => d.id)
        .exit()
            .each(removeDashedLine);

    const distances = people.map(p => distance([evt.x, evt.y], [p.x, p.y]));
    const index = smallest(distances);
    if (distances[index] < 30) {
        const newRelation = {
            id: relationCounter,
            source: datum,
            target: people[index]
        };
        relationCounter += 1;
        relations.push(newRelation);

        base.selectAll(lineSelector)
            .data(relations, d => d.id)
            .enter()
                .each(createConnection);
    }

}

function onRemoveConnectionClicked(evt, datum) {
    const index = findIndex(relations, c => c.id === datum.id);
    relations.splice(index, 1);
    base.selectAll(lineSelector)
            .data(relations, d => d.id)
            .exit()
                .each(removeConnection);
}


/****************************************************************
 *      Part 4: CRUD components
 ****************************************************************/

function createLabeledBubble(datum, index, nodes) {
    const selection = select(nodes[index]);
    const group = selection
        .append('g')
        .attr('class', bubbleSelector.slice(1))    
        .call(dragBehavior)
        .attr('transform', `translate(${datum.x}, ${datum.y})`)
        .on('mouseover', function(evt, datum) {
            select(this).select('circle').attr('fill-opacity', 0.9)
        })
        .on('mouseout', function(evt, datum) {
            select(this).select('circle').attr('fill-opacity', 0.6)
        });
    group
        .append('circle')
        .attr('fill', shade0Primary)
        .attr('fill-opacity', 0.6)
        .attr('stroke', shade3Primary)
        .attr('stroke-width', 1)
        .attr('r', 0)
        .transition()
            .duration(250)
            .ease(easeBounce)
            .attr('r', 10);
    group
        .append('text')
        .attr('fill', 'white')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .text(datum.id);
        //https://stackoverflow.com/questions/5546346/how-to-place-and-center-text-in-an-svg-rectangle
}

function updateLabeledBubble(datum, index, nodes) {
    const selection = select(nodes[index]);
    selection.attr('transform', `translate(${datum.x}, ${datum.y})`);
}

function createDashedLine(datum, index, nodes) {
    const selection = select(nodes[index]);
    selection
        .append('line')
        .attr('class', dashedLineSelector.slice(1))
        .attr('x1', datum.source.x)
        .attr('y1', datum.source.y)
        .attr('x2', datum.target.x)
        .attr('y2', datum.target.y)
        .attr('stroke', shade3Primary)
        .attr('stroke-dasharray', 5)
        .lower();
}

function updateDashedLine(datum, index, nodes) {
    const selection = select(nodes[index]);
    selection
        .attr('x2', datum.target.x)
        .attr('y2', datum.target.y);
}

function removeDashedLine(datum, index, nodes) {
    const selection = select(nodes[index]);
    selection.remove();
}

function createConnection(datum, index, nodes) {
    const selection = select(nodes[index]);
    const group = selection
        .append('g')
        .attr('class', lineSelector.slice(1))
        .on('mouseover', function(evt, datum) {
            select(this).select('line').attr('stroke-width', 3);
            select(this).select('.close-icon').attr('visibility', 'visible');
        })
        .on('mouseout', function(evt, datum) {
            select(this).select('line').attr('stroke-width', 1);
            select(this).select('.close-icon').attr('visibility', 'hidden');
        })
        .lower();
    group
        .append('line')
        .attr('x1', datum.source.x)
        .attr('y1', datum.source.y)
        .attr('x2', datum.target.x)
        .attr('y2', datum.target.y)
        .attr('stroke', shade2Secondary2);
    group
        .append(createCloseButton)
        .attr('visibility', 'hidden');
}

function updateConnection(datum, index, nodes) {
    const selection = select(nodes[index]);
    selection.select('line')
        .attr('x1', datum.source.x)
        .attr('y1', datum.source.y)
        .attr('x2', datum.target.x)
        .attr('y2', datum.target.y);
    selection.select('.close-icon')
        .attr('transform', `translate(${(datum.source.x + datum.target.x) / 2}, ${(datum.source.y + datum.target.y) / 2})`);
}

function removeConnection(datum, index, nodes) {
    const selection = select(nodes[index]);
    selection.remove();
}

function createCloseButton(datum, index, nodes) {
    const group = create('svg:g')
        .attr('class', 'close-icon')    
        .call(dragBehavior)
        .attr('transform', `translate(${(datum.source.x + datum.target.x) / 2}, ${(datum.source.y + datum.target.y) / 2})`);
    group
        .append('circle')
        .attr('fill', shade0Complement)
        .attr('fill-opacity', 0.6)
        .attr('stroke', shade3Complement)
        .attr('stroke-width', 1)
        .attr('r', 7);
    group
        .append('text')
        .attr('fill', 'white')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'middle')
        .text('x');
    group.on('click', onRemoveConnectionClicked);
    return group.node();
}


/****************************************************************
 *      Part 5: helpers
 ****************************************************************/

function distance(p1, p2) {
    return Math.sqrt(
        Math.pow(p1[0] - p2[0], 2) + 
        Math.pow(p1[1] - p2[1], 2)
    );
}

function smallest(data) {
    let index = 0;
    let smallest = data[index];
    for (let i = 0; i < data.length; i++) {
        if (data[i] < smallest) {
            index = i;
            smallest = data[index];
        }
    }
    return index;
}

function findIndex(data, predicate) {
    for (let i = 0; i < data.length; i++) {
        if (predicate(data[i])) {
            return i;
        }
    }
}

```


## SVG

 - units
    - percentages: always relative to the nearest parent svg-element or symbol-element. (More exactly: to the view-box of the element if given, otherwise to the elements actual size)
 - g
    - don't have a width or height. They grow to their contents.
    - do allow `translate`, though
    - group attributes cascade down to all children
    - groups can be nested
 - svg
    - do have a width and height
    - may be nested
 

## Colors

 - great color picker: https://www.sessions.edu/color-calculator/




## Enter/Updade/Exit
<img src="../assets/programming/d3_enter_update_exit.png"  width="200px" style="margin: 3rem;"/>

```html
    <html>
    <head>
        <script src="https://d3js.org/d3.v6.js"></script>
    </head>
    <body>
        <h1>Demonstrating the selection, enter & exit flow for animations</h1>

        <ul id="list">
            <li>one</li>
            <li>two</li>
        </ul>

        <p>
            To explore this behavior, call `displayData` a few times from the web-console.
        </p>
    </body>
    <script>
        function displayData(data) {
            // step 1: create element- & data-selections (= the blue and the red cirlce)
            const elsNdata = d3.select('#list')  // selection of parent element
                .selectAll('li')  // select all child elements: [li, li]
                .data(data);

            // step 2: handle li's that already have (possibly old) data on them
            elsNdata
                .text(d => d);
            // usually, there are initially no pre-defined li's, such that this step is not required.
            // this is good for performance: not handling old items saves on dom-operations.
    
            // step 3: handle new data points coming in
            elsNdata.enter()  // all data points that have not yet got an associated li
                    .append('li')
                    .text(d => d);
            
            // step 4: handle old data points going out
            elsNdata.exit() // all li's that no longer have data on them
                .remove();
        }

        displayData([1, 2, 3])
    </script>
</html>
```


```js
    import { select, BaseType, EnterElement, Selection } from 'd3';


    // https://www.youtube.com/watch?v=IyIAR65G-GQ&t=1841s 
    
    interface DataPoint {
        id: number;
        value: number;
    }
    
    class Queue<T> {
        private data: T[];
        
        constructor(length: number) {
            this.data = Array(length);
        }
    
        push(val: T): T {
            this.data.push(val);
            return this.data.shift();
        }
    
        getData(): T[] {
            return this.data;
        }
    }
    
    const dataQueue = new Queue<DataPoint>(10);
    
    let id = 0;
    function addRandomData(queue: Queue<DataPoint>) {
        id += 1;
        queue.push({
            id: id,
            value: Math.random() * 10
        });
    }
    
    for (let i = 0; i < 10; i++) {
        addRandomData(dataQueue);
    }
    
    const baseElement: Selection<SVGElement, unknown, HTMLElement, any> = select('#svg')
        .attr('width', 300)
        .attr('height', 300)
        .append('g');
        
    function update(data: DataPoint[]) {
        
        // we need to re-select on every update cycle
        const circles: Selection<BaseType, unknown, SVGElement, unknown> = baseElement.selectAll('circle');
        const circlesWithData: Selection<BaseType, DataPoint, SVGElement, unknown> = circles
            .data(data, 
                // keyFunction: returns an id for each datum, so that elements know what data they are associated with
                (d: DataPoint, i: number, g: (SVGElement | BaseType)[]) => d.id
            );
        
        const entering: Selection<EnterElement, DataPoint, SVGElement, unknown> = circlesWithData.enter();
        const updating: Selection<BaseType, DataPoint, SVGElement, unknown> = circlesWithData;
        const enteringAndUpdating = updating.merge(entering);
        const leaving: Selection<BaseType, unknown, SVGElement, unknown> = circlesWithData.exit();
        console.log(`in: ${entering.size()} - update: ${updating.size()} - out: ${leaving.size()}`)
        
        const entered: Selection<SVGCircleElement, DataPoint, SVGElement, unknown> = entering
            .append('circle')
            .attr('r', 10)
            .attr('cx', (d, i) => i * 20)
            .attr('cy', (d) => 250 - d.value * 10)
            .attr('fill', 'green');
    
        const updated: Selection<BaseType, DataPoint, SVGElement, unknown> = updating
            .attr('cx', (d, i) => i * 10);
        
        const removed: Selection<BaseType, unknown, SVGElement, unknown> = leaving.remove();
    }
    
    const button = document.getElementById('button') as HTMLButtonElement;
    button.addEventListener('click', () => {
        addRandomData(dataQueue);
        const newData = dataQueue.getData();
        update(newData);
    }); 
```


## Updates
A `Selection`s groups (update, enter and exit) stay the same, even if the data has already been modified.
To get the newer entries in the `update` group, you need to make a new `Selection` using `.selectAll('someTag')`.

## Call vs each
Call is a synonym to `tap`: it allows you to have a side-effect on a selection without breaking the method chain.

```js
selectAll('circle')
    .call(doWithSelection, 'red');

function doWithSelection(selection, color) {
    selection.attr('fill', color);
}
```
Note that call is being called *exactly once*. Consider this example:
```js
selectAll('circle')
    .data(someData)
    .enter()
        .append('circle')
    .call(doWithSelection, 'red');
```
Here `doWithSelection` is called *only once* on the whole `selectAll('circle')` selection, not once for each circle.
The reason is that `call` always works on a selection. The enter-method however only returns the enter-property of the last selection.

If you want to have a function called for each datum, use `each` instead.
`each` invokes the specified function for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with `this` as the current DOM element (nodes[i]). This method can be used to invoke arbitrary code for each selected element...
Note that you need to `select(this)` first:
```js
const connections = root.selectAll('line')
    .data(relations)
    .enter()
        .append(d => createConnection(d))
        .each(function(datum, i) {
            select(this)
                .style('stroke', 'yellow')
                .style('stroke-width', 10);
        });
```

## Modularization: detached elements
Update: detached elements are actually more of a niche case than I thought. More idiomatically, one should probably use `each` instead.

It's actually a little hard to split d3-code into sub-functions. Mostly because it relies so heavily on passing along context using `this`. But there is a way. Note how this requires the use of the `svg` namespace
```js
import {select, create, forceCenter, forceLink, forceManyBody, forceSimulation, line } from 'd3';


/****************************************************************
 *      Part 0: settings
 ****************************************************************/

const width = 600;
const height = 400;

/****************************************************************
 *      Part 1: data
 ****************************************************************/

const people = [{
    name: 'Andreas'
}, {
    name: 'Michael'
}, {
    name: 'Chloe'
}, {
    name: 'Stefan'
}, {
    name: 'Eva'
}];

const relations = [{
    source: people.find(p => p.name === 'Andreas'),
    target: people.find(p => p.name === 'Michael')
}, {
    source: people.find(p => p.name === 'Andreas'),
    target: people.find(p => p.name === 'Chloe')
}, {
    source: people.find(p => p.name === 'Chloe'),
    target: people.find(p => p.name === 'Stefan')
}, {
    source: people.find(p => p.name === 'Michael'),
    target: people.find(p => p.name === 'Eva')
}, {
    source: people.find(p => p.name === 'Michael'),
    target: people.find(p => p.name === 'Chloe')
}];

/****************************************************************
 *      Part 2: layouts
 ****************************************************************/
const simulation = forceSimulation(people)
    .force('charge', forceManyBody().strength(-300))
    .force('center', forceCenter(width / 2, height / 2))
    .force('connection', forceLink(relations))
    .on('tick', tick);

function tick(evt) {
    updateBubbles(bubbles);
    updateConnections(connections);
}

function updateBubbles(bubbles) {
    bubbles
        .attr('transform', (d, i) => `translate(${d.x}, ${d.y})`);
}

function updateConnections(connections) {
    connections
        .attr('x1', d => d.source.x)
        .attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x)
        .attr('y2', d => d.target.y);
}


/****************************************************************
 *      Part 3: components
 ****************************************************************/

function createLabeledCircle(d) {
    const g = create('svg:g');
    g.append('circle').attr('r', 30).attr('fill', 'green').attr('outline', 'black');
    g.append('text').text(d.name).attr('text-anchor', 'middle').attr('x', 50).attr('y', 20);
    return g.node();
}

function createConnection(d) {
    const l = create('svg:line')
        .style('stroke', 'black')
        .style('stroke-width', 1);
    return l.node();
}

const svg = select('#graph').attr('width', width).attr('height', height);

const root = svg.append('g');

const bubbles = root.selectAll('circle')
    .data(people)
    .enter()
        .append(d => createLabeledCircle(d));

const connections = root.selectAll('line')
    .data(relations)
    .enter()
    .append(d => createConnection(d));
```


## Generators, components and layouts
The information here stems from [manning](https://livebook.manning.com/book/d3-js-in-action/chapter-5/7).
The three main types of functions in D3 can be classified as generators, components and layouts. 

<img src="../assets/programming/d3_comps_gens_lays.jpg" />


### Layouts
Layout is a way how d3 arranges data for you - commonly in a tree, or a circle-diagram or comparable. In this example below you wrap your data in a `hierarchy` (which, I think, might be a layout itself), then you call a layout-function (like for example `cluster`) on it.
```js
    import { select, cluster, curveBundle, lineRadial, dsv, hierarchy } from 'd3';


    const width = 700;
    const height = 500;
    const circleRadius = 200;
    
    
    function findInTree(name, parentGroupName, tree) {
        const parentGroup = tree.children.find(e => e.name === parentGroupName);
        if (parentGroup) {
            const entry = parentGroup.children.find(e => e.name === name);
            return entry;
        }
    }
    
    function addToTree(name, parentGroupName, tree) {
        const parentGroup = tree.children.find(e => e.name === parentGroupName);
        parentGroup.children.push({
            name, parentGroupName,
            in: [],
            out: []
        });
    }
    
    function findInHierarchy(name, groupName, hierarchy) {
        const group = hierarchy.children.find(c => c.data.name === groupName);
        if (group) {
            const child = group.children.find(c => c.data.name === name);
            return child;
        }
    }
    
    function parseDataInTree(data) {
    
        // step 0: base data
        const base = {
            name: 'base',
            children: [{
                name: 'cluster',
                children: []
            }, {
                name: 'project',
                children: []
            }, {
                name: 'potential',
                children: []
            }, {
                name: 'institute',
                children: []
            }]
        };
    
        // step 1: hierarchy
        for (let row of data) {
            const institute = row['DLR Institut'];
            if (!findInTree(institute, 'institute', base)) {
                addToTree(institute, 'institute', base);
            }
            const potential = row['Potential'];
            if (!findInTree(potential, 'potential', base)) {
                addToTree(potential, 'potential', base);
            }
            const project = row['Projekt'];
            if (!findInTree(project, 'project', base)) {
                addToTree(project, 'project', base);
            }
            const cluster = row['HumTech Cluster (UNHCR)'];
            if (!findInTree(cluster, 'cluster', base)) {
                addToTree(cluster, 'cluster', base);
            }
    
        }
        const hierarchyData = hierarchy(base);
    
        // step 2: connections at leaf-level
        for (let row of data) {
            const institute = row['DLR Institut'];
            const potential = row['Potential'];
            const project = row['Projekt'];
            const cluster = row['HumTech Cluster (UNHCR)'];
    
            if (institute && potential) {
                const startNode = findInHierarchy(institute, 'institute', hierarchyData);
                const targetNode = findInHierarchy(potential, 'potential', hierarchyData);
                startNode.data.out.push(targetNode);
                targetNode.data.in.push(startNode);
            }
    
            if (institute && project) {
                const startNode = findInHierarchy(institute, 'institute', hierarchyData);
                const targetNode = findInHierarchy(project, 'project', hierarchyData);
                startNode.data.out.push(targetNode);
                targetNode.data.in.push(startNode);
            }
    
            if (project && cluster) {
                const startNode = findInHierarchy(project, 'project', hierarchyData);
                const targetNode = findInHierarchy(cluster, 'cluster', hierarchyData);
                startNode.data.out.push(targetNode);
                targetNode.data.in.push(startNode);
            }
    
            if (potential && cluster) {
                const startNode = findInHierarchy(potential, 'potential', hierarchyData);
                const targetNode = findInHierarchy(cluster, 'cluster', hierarchyData);
                startNode.data.out.push(targetNode);
                targetNode.data.in.push(startNode);
            }
        }
    
        return hierarchyData;
    }
    
    function getBubbleColor(d) {
        if (d.depth === 2) {
            switch (d.parent.data.name) {
                case 'cluster':
                    return 'yellow';
                case 'project':
                    return 'blue';
                case 'institute':
                    return 'green';
                case 'potential':
                    return 'red';
            }
        } else if (d.depth === 1) {
            return 'black';
        } else {
            return 'black';
        }
    }
    
    function getPathsFromTree(treeData) {
        const paths = [];
    
        for (let source of treeData.leaves()) {
            for (let target of source.data.out) {
                const path = source.path(target);
                paths.push(path);
            }
        }
    
        return paths;
    }
    
    function getConnectedPaths(node) {
        const paths = [];
        for (let input of node.data.in) {
            const path = input.path(node);
            paths.push(path);
        }
        for (let output of node.data.out) {
            const path = output.path(node);
            paths.push(path);
        }
        return paths;
    }
    
    function getConnectedNodes(node) {
        const nodes = [];
        for (let input of node.data.in) {
            nodes.push(input);
        }
        for (let output of node.data.out) {
            nodes.push(output);
        }
        return nodes;
    }
    
    
    async function main() {
        function highlightConnections(connectedPaths) {
            const highlightedConnections = baseElement
                .selectAll('.highlightedConnection')
                .data(connectedPaths);
            highlightedConnections
                .enter()
                    .append('path')
                    .attr('class', 'highlightedConnection')
                    .attr('d', connectionPathFunction)
                    .attr('stroke', 'black')
                    .attr('fill', 'none')
            highlightedConnections
                .exit()
                    .remove();
        }
    
        function highlightNodes(nodes) {
            const highlightedNodes = baseElement
                .selectAll('.highlightedNode')
                .data(nodes);
            highlightedNodes
                .enter()
                    .append('circle')
                    .attr('class', 'highlightedNode')
                    .attr('r', 15)
                    .attr('transform', d => `rotate(${d.x - 90}) translate(${d.y}, 0)`)
                    .attr('fill', 'black');
            highlightedNodes
                .exit()
                    .remove();
        }
    
        function onMouseOver(evt, d) {
            const connectedPaths = getConnectedPaths(d);
            const connectedNodes = getConnectedNodes(d);
            highlightConnections(connectedPaths);
            highlightNodes(connectedNodes);
        }
        
        function onMouseOut(evt, d) {
            highlightConnections([]);
            highlightNodes([]);
        }
    
        const data = await dsv('|', './data2.csv');
    
        const treeData = parseDataInTree(data);
        const pathData = getPathsFromTree(treeData);
    
        const baseElement = select('#graphic')
            .attr('width', width)
            .attr('height', height)
            .append('g')
            .attr('transform', `translate(${width / 2} ${height / 2})`);
    
        const circlePositioningFunction = cluster()
            .size([360, circleRadius]);
        const treeDataWithPositions = circlePositioningFunction(treeData);
        const leafDataWithPositions = treeDataWithPositions.leaves();
    
        const connectionPathFunction = lineRadial()
            .curve(curveBundle.beta(0.7))
            .radius(d => d.y)
            .angle(d => d.x / 180 * Math.PI);
    
        const connections = baseElement
            .selectAll('.connection')
            .data(pathData)
            .enter()
            .append('path')
            .attr('class', 'connection')
            .attr('d', connectionPathFunction)
            .attr('stroke', 'gray')
            .attr('fill', 'none');
    
        const circles = baseElement
            .selectAll('.bubble')
            .data(leafDataWithPositions)
            .enter()
            .append('circle')
            .attr('class', 'bubble')
            .attr('r', 10)
            .attr('fill', d => getBubbleColor(d))
            .attr('stroke', 'black')
            .attr('transform', d => `rotate(${d.x - 90}) translate(${d.y}, 0)`)
            .on('mouseover', onMouseOver)
            .on('mouseout', onMouseOut);
    
    }
    
    main();
```



### Layouts

Layouts don’t draw the data, nor are they called like components or referred to in the drawing code like generators.
Rather, they’re a preprocessing step that formats your data so that it’s ready to be displayed in the form you’ve chosen.
Layouts take a set of input data, apply an algorithm or heuristic,
and output the resulting positions/shapes for a cohesive display of the data.
You can update a layout, and then if you rebind that altered data to your graphical objects, you can use the D3 enter/update/exit syntax to update your layout.

Layouts: 
- `Bundle|Bundle-Layout` - apply Holten's hierarchical bundling algorithm to edges.
- `Chord|Chord-Layout` - produce a chord diagram from a matrix of relationships.
- `Cluster|Cluster-Layout` - cluster entities into a dendrogram.
- `Force|Force-Layout` - position linked nodes using physical simulation.
- `Hierarchy|Hierarchy-Layout` - derive a custom hierarchical layout implementation.
- `Histogram|Histogram-Layout` - compute the distribution of data using quantized bins.
- `Pack|Pack-Layout` - produce a hierarchical layout using recursive circle-packing.
- `Partition|Partition-Layout` - recursively partition a node tree into a sunburst or icicle.
- `Pie|Pie-Layout` - compute the start and end angles for arcs in a pie or donut chart.
- `Stack|Stack-Layout` - compute the baseline for each series in a stacked bar or area chart.
- `Tree|Tree-Layout` - position a tree of nodes tidily.
- `Treemap|Treemap-Layout` - use recursive spatial subdivision to display a tree of nodes.


Some layouts are even dynamic through time: for example, you `start()` a `d3.layout.force()` instance and then listen for layout updates on 'tick' events.
These are called `simulations`. The `forceSimulation` is certainly one of the most prominent members of these layouts.

#### Custom layouts
Creating a custom layout is easy. Really it's just a function that add's some position-data to the given set of data-points.
```js
function myLayout() {
   var space = 1;
   function compute(data) {
       // same as before
   }
   compute.space = function(s) {
       if (!arguments.length) return space;
       space = s;
       return this;   // chaining
   }
   return compute;
}
var layout = myLayout().space(10);
var nodes = layout(myData);
```


### Generators
Contrary to layouts, generators work on single data-points. They don't modify the data-points, either,
but use their (x- and y-)properties for drawing. (In the case of svg's, that drawing consists of simply returning a `svg.d` path string.)
   - `d3.line`:	Generates path data for a multi-segment line (typically for line charts)
   - `d3.area`:	Generates path data for an area (typically for stacked line charts and stream-graphs)
   - `d3.stack`:	Generates stack data from multi-series data
   - `d3.arc`:	Generates path data for an arc (typically for pie charts)
   - `d3.pie`:	Generates pie angle data from array of data
   - `d3.symbol`:	Generates path data for symbols such as plus, star, diamond

#### Custom generators
You can create your own generators like so:
```js
This is certainly possible, you would need to create this generator from scratch, i.e.:

function circleGen() {
  //set defaults
  var r = function(d) { return d.radius; },
      x = function(d) { return d.x; },
      y = function(d) { return d.y; };

  //returned function to generate circle path
  function circle(d) {
    var cx = d3.functor(x).call(this, d),
        cy = d3.functor(y).call(this, d),
        myr = d3.functor(r).call(this, d);

    return "M" + cx + "," + cy + " " +
           "m" + -myr + ", 0 " +
           "a" + myr + "," + myr + " 0 1,0 " + myr*2  + ",0 " +
           "a" + myr + "," + myr + " 0 1,0 " + -myr*2 + ",0Z";
  }

  //getter-setter methods
  circle.r = function(value) {
    if (!arguments.length) return r; r = value; return circle;
  };  
  circle.x = function(value) {
    if (!arguments.length) return x; x = value; return circle;
  };  
  circle.y = function(value) {
    if (!arguments.length) return y; y = value; return circle;
  };

  return circle;
}
```
And use it like so:
```js
var myC = circleGen()
   .x(function(d) { return d.x; })
   .y(function(d) { return d.y; })
   .r(function(d) { return d.r; });

var data = [
  {x: 150, y: 100, r: 10, fill: "green"},
  {x: 200, y: 150, r: 5, fill: "red"},
  {x: 100, y: 250, r: 25, fill: "blue"}
];

svg.selectAll("path.circle")
    .data(data)
  .enter().append("path")
    .attr("class", "circle")
    .attr("d", myC)
    .style("fill", function(d) { return d.fill; });
```

### Components

In contrast with generators, which produce the d attribute string necessary for a `<path>` element, components create an entire set of graphical objects necessary for a particular chart component. The most commonly used D3 component (which you’ll see in this chapter) is d3.svg.axis, which creates a bunch of `<line>`, `<path>`, `<g>`, and `<text>` elements that are needed for an axis based on the scale and settings you provide the function.


#### Custom components
Components are always functions that take a `selection` as their only argument and return `this`.
```js
function myComponent(selection) {
    selection.append(<... something to append ...>);
    return this;
}
```
Commonly components are provided inside closures so that the user can append options.


## Range & scale
Scales are a type of layout.
- `scaleSequential`: 
- `scaleOrdinal`: Domain: a categorical list. 
- `scaleBand`: used for bar-chats and the like. Domain: a categorical list. 

### Custom scale
```js
const entries = [{
  color: 'rgb(255, 0, 0)',
  text: 'red',
  position: 0.0
}, {
  color: 'rgb(0, 255, 0)',
  text: 'green',
  position: 0.5
}, {
  color: 'rgb(0, 0, 255)',
  text: 'blue',
  position: 1.0
}];

function scaleColor() {

  // default parameters
  let domain = [0, 1];
  let range = ['rgb(255, 0, 0)', 'rgb(0, 0, 255)'];

  // actual interpolation
  function interpolate(rStart, rEnd, rel) {
    const cStart = color(rStart);
    const cEnd = color(rEnd);
    const cStartHSL = hsl(cStart);
    const cEndHSL = hsl(cEnd);
    const hInterp = cStartHSL.h + rel * (cEndHSL.h - cStartHSL.h);
    const sInterp = cStartHSL.s + rel * (cEndHSL.s - cStartHSL.s);
    const lInterp = cStartHSL.l + rel * (cEndHSL.l - cStartHSL.l);
    const interpHSL = hsl(hInterp, sInterp, lInterp);
    return interpHSL.rgb().toString();
  }

  // deciding, which colors to interpolate between
  function scale(d) {
    for (let i = 0; i < domain.length; i++) {
      const dStart = domain[i];
      const dEnd = domain[i+1];
      if (d < dStart) {
        return range[0];
      }
      if (dStart <= d && d < dEnd) {
        const rStart = range[i];
        const rEnd = range[i + 1];
        const rel = (d - dStart) / (dEnd - dStart);
        return interpolate(rStart, rEnd, rel);
      }
      if (dEnd < d) {
        return range[range.length - 1];
      }
    }
  };

  // public methods
  scale.domain = function(d) { domain = d; return scale; };
  scale.range = function(r) { range = r; return scale; };

  return scale;
}

const colorScale = scaleColor()
  .domain(entries.map(e => e.position))
  .range(entries.map(e => e.color));
```


## Behaviors
Behaviors are event systems. They expose a few `on` events and are added onto a selection using `selection.call(behavior)`
Common behaviors:
   - zoom: exposes `zoom` event
   - drag: exposes `start`, `drag`, `end` events


## Force
One of the hardest parts of d3 is the usage of force in combination with drag.
```js
    import { BaseType, forceCenter, forceLink, forceManyBody, select, Selection } from "d3";
import { forceSimulation, SimulationLinkDatum, SimulationNodeDatum } from "d3-force";
import { drag } from 'd3-drag';

/**
Each node must be an object. The following properties are assigned by the simulation:

index: the node's zero-based index into nodes
x - the node's current x-position
y - the node's current y-position
vx - the node's current x-velocity
vy - the node's current y-velocity

The position (x, y) and velocity (vx, vy) may be subsequently modified by forces and by the simulation.
If either vx or vy is NaN, the velocity is initialized to (0, 0). If either x or y is NaN,
the position is initialized in a phyllotaxis arrangement, so chosen to ensure a deterministic, uniform distribution.

Each link is an object with the following properties:

source - the link's source node; see simulation.nodes
target - the link's target node; see simulation.nodes
 */

interface Institute extends SimulationNodeDatum {
    id: string;
}

const institutes: Institute[] = [{
    id: 'finance'
}, {
    id: 'spaceflight'
}, {
    id: 'research'
}];

const links: SimulationLinkDatum<Institute>[] = [{
    source: institutes.find(i => i.id === 'spaceflight'),
    target: institutes.find(i => i.id === 'finance')
}, {
    source: institutes.find(i => i.id === 'spaceflight'),
    target: institutes.find(i => i.id === 'research')
}];




const simulation = forceSimulation(institutes)
    .force("charge", forceManyBody().strength(-30))
    .force("link", forceLink(links))
    .force("center", forceCenter().x(150).y(150))
    .on('tick', simulationTick);

const dragCallback = drag()
    .on('start', (evt: DragEvent, d: Institute) => {
        simulation.alphaTarget(0.3).restart(); 
    })
    .on('drag', (evt, d: Institute) => {
        d.fx = evt.x;
        d.fy = evt.y;
    })
    .on('end', (evt: DragEvent, d: Institute) => {
        simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    });


const rootElement = select('#svg')
    .attr('width', 500)
    .attr('height', 300)
    .append('g');

rootElement.selectAll('circle')
    .data(institutes)
    .enter()
        .append('circle')
        .attr('r', 10)
    .call(dragCallback);

rootElement.selectAll('line')
    .data(links)
    .enter()
        .append('line')
        .attr('stroke', 'black')
        .attr('stroke-width', 2);

function simulationTick() {
    rootElement.selectAll('circle')
        .attr('cx', d => (d as Institute).x)
        .attr('cy', d => (d as Institute).y);

    rootElement.selectAll('line')
        .attr('x1', d => ((d as SimulationLinkDatum<Institute>).source as Institute).x)
        .attr('y1', d => ((d as SimulationLinkDatum<Institute>).source as Institute).y)
        .attr('x2', d => ((d as SimulationLinkDatum<Institute>).target as Institute).x)
        .attr('y2', d => ((d as SimulationLinkDatum<Institute>).target as Institute).y);
}
```


