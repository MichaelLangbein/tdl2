# D3

## SVG

- units
  - percentages: always relative to the nearest parent svg-element or symbol-element. (More exactly: to the view-box of the element if given, otherwise to the elements actual size)
- g
  - don't have a width or height. They grow to their contents.
  - do allow `transform`, though
  - group attributes cascade down to all children
  - groups can be nested
- svg
  - do have a width and height
  - may be nested
  - may not have `transform`. Firefox does respect a svg-transform, but that's an exception.
    - https://stackoverflow.com/questions/33058883/nested-svg-ignores-transformation-in-chrome-and-opera
- transforms:
  - For SVG elements, the origin is, assuming we have no transform applied on the element itself or any of its ancestors inside the <svg> element, at the 0 0 point of the next parent svg.
    - https://css-tricks.com/transforms-on-svg-elements/

#### Header

```svg
<?xml version="1.0" encoding="utf-8"?>

<!-- xmlns="http://www.w3.org/2000/svg" required for display in browsers -->
<svg width="100" height="30" viewBox="0 0 100 30" xmlns="http://www.w3.org/2000/svg">
```

#### Rotations in svg's are relative to the nearest parent-svg, not to the root svg.

```svg
<svg id="outer" width="500" height="500" viewBox="0 0 100 100" style="background-color: lightblue;">

    <!-- indicating center of svg -->
    <rect x="49" y="49" width="2" height="2" fill="gray"></rect>

    <!-- rotated around `outer`'s top left -->
    <rect x="50" y="50" width="50" height="10" transform="rotate(10)" fill="#629c70"></rect>

    <svg id="inner" width="50" height="50" viewBox="0 0 100 100" x="50" y="50" style="background-color: red;">
        <!-- rotated around `inner`'s top left -->
        <rect x="0" y="0" width="100" height="20" transform="rotate(10)" fill="#62819c"></rect>
    </svg>
</svg>
```

##### Mask

```svg
<svg width="100" height="100" style="background-color: lightblue;">

    <mask id="msk">
        <!-- everything black will be hidden -->
        <rect width="100" height="100" fill="black"></rect>
        <!-- everything white will be visible -->
        <circle cx="50" cy="50" r="20" fill="white"></circle>
    </mask>

    <!-- actually, more often we'd apply the mask to a sub-svg -->
    <rect x="10" y="10" width="80" height="80" fill="magenta" mask="url(#msk)"></rect>

</svg>
```

#### Path

Upper case: absolute, lower case: relative

- `M x,y`: place brush here
- `L x,y`: draw line to `x,y`
- `C x1,y1, x2,y2, xd,yd`: draw Bezier curve with first handle at `x1,y1`, second handle at `x2,y2` and target at `xd,yd`
- `S x2,y2, xd,yd`: like `C`, but assumes that first handle is mirror of the previous curve's second handle
- `Q x,y, xd,yd`: like `C`, but assumes that first and second handle are in same place
- `T`:
- `A`: elliptical arch
- `Z`: draw straight line to last `M` position

#### `Defs` and `Use`

```svg
<svg id="outer" width="500" height="500" viewBox="0 0 100 100" style="background-color: lightblue;">

    <defs>
        <path id="blade" d="M 0,50 C 10,50, 0,30, 0,0 Z"></path>
    </defs>

    <use href="#blade" x="50" y="0" transform="" />
    <use href="#blade" x="50" y="0" transform="rotate(120 50 50)" />
    <use href="#blade" x="50" y="0" transform="rotate(240 50 50)" />
</svg>
```

#### Placing a graphic in such a way that it can be easily rotated around its center

- graphic rel to `0, 0, 100, 100`
- graphic in group: provides rotation around `50 50`
- group in svg: provides translation and scaling

```svg
<svg width="500" height="300" id="outer" style="background-color: lightblue;">
    <!-- placed svg. viewBox set to `0 0 100 100` such that rotation is around `50 50` -->
    <svg id="placed" x="${xPos}" y="${yPos}" width="${width}" height="${width}" viewBox="0 0 100 100">
        <defs>
            <path id="blade" d="M 0,50 C 9,40, 0,30, 0,0 Z" fill="gray" stroke="black" stroke-width="0.1"></path>
        </defs>
        <!-- grouped, such that rotation applies to all at same time -->
        <g transform="rotate(${rotationDegrees} 50 50)">
            <use href="#blade" x="50" y="0" transform="" />
            <use href="#blade" x="50" y="0" transform="rotate(120 50 50)" />
            <use href="#blade" x="50" y="0" transform="rotate(240 50 50)" />
            <circle cx="50" cy="50" r="3" fill="gray" stroke="black" stroke-width="0.1"></circle>
        </g>
    </svg>
</svg>
```

#### Common shapes

**Triangle**:

```svg
    <svg x="47" y="47" width="50" height="50" viewBox="0 0 100 100">
        <g transform="rotate(40 50 50)">
            <path d="M 50 0 L 93.3 75 L 6.7 75 Z"></path>
        </g>
    </svg>
```

#### Example: wind-power header

```svg

<?xml version="1.0" encoding="utf-8"?>


<svg width="100" height="35" id="outer" xmlns="http://www.w3.org/2000/svg">

    <mask id="outlineMask">
        <rect width="100" height="35"></rect>
        <path d="M 0,0 L 100,0 L 100,30 C 80,25, 59,30, 40,30 S 10,20, 0, 25 Z" fill="white"></path>
    </mask>

    <defs>
        <linearGradient id="skyGrad" x1="0" x2="0" y1="0" y2="1">
            <stop offset="0%" stop-color="#00e1ff" />
            <stop offset="100%" stop-color="#fcfcfc" />
        </linearGradient>
    </defs>

    <svg id="contents" mask="url(#outlineMask)">

        <rect width="100" height="35" fill="url(#skyGrad)"></rect>

        <svg id="fullBuilding" x="5" y="5" width="20" height="40" viewBox="0 0 100 200">

            <rect x="47.5" y="46" width="5" height="100" fill="white"></rect>
            <rect x="45" y="46" width="10" height="8" fill="white"></rect>

            <svg id="fullRotor" x="0" y="0" width="100" height="100" viewBox="0 0 100 100">
                <defs>
                    <path id="blade" d="M 0,50 C 9,40, 0,30, 0,0 Z" fill="white"></path>
                </defs>
                <g transform="rotate(10 50 50)">
                    <svg x="45" y="45" width="10" height="10" viewBox="0 0 100 100">
                        <g transform="rotate(15 50 50)">
                            <path d="M 50 0 L 93.3 75 L 6.7 75 Z" fill="white"></path>
                        </g>
                    </svg>
                    <use href="#blade" x="50" y="0" transform="" />
                    <use href="#blade" x="50" y="0" transform="rotate(120 50 50)" />
                    <use href="#blade" x="50" y="0" transform="rotate(240 50 50)" />
                    <circle cx="50" cy="50" r="2.5" fill="white"></circle>
                </g>
            </svg>

        </svg>

    </svg>

</svg>
```

## Colors

- great color picker: https://www.sessions.edu/color-calculator/

## Concept summaries

- d3 uses a lot of closures, approximating classes.
- allmost all methods of those closures return this; Thus implementing the method-chaining pattern.
- There are the following types of closures:

  - selection: manages svg-nodes and data
  - layout: mutates data to add display-information
  - generator: takes datum and returns svg-node
  - component: takes selection and appends stuff

- d3 chains `selections`
- `selections` manage
  - selected html/svg-`node`s.
  - `selection.enter`: incoming data that'll be converted to `node`s
  - `selection.exit` outgoing data
- `selections` have methods that offer data to a `callback` and return another selection
  ```js
  calback: (datum, index, nodes) -> void
  selection.method(callback) -> selection
  ```
- Through calling those methods you can make the selection modify its `node`s.
  - If inside a `callback` you need to access the `selection`, use `this` or `select(nodes[index])`
- a special method is `append`: here you can add `node`s directly
  - ... either as a string: `"g"`, or `"rect"`, ...
  - ... or by creating a custom node:
    ```js
    const selection = create("svg:g");
    selection.doSth();
    return selection.node();
    ```
- `layout`: modifies data to add information about its placement
- `generators`: take a datum and transform it into simple svg-element-node(s)
  ```js
  generator = closure((datum) => node[], methods)
  generator.method()
  selection.attr('d', generator)
  ```
- `components`: take a selection and modify it with more selecions
  ```js
  component = closure((selection) => void, methods)
  component.method()
  selection.call(component)
  ```

## Important concepts and misconceptions

- D3 is **not reactive**. A selection, once made, contains only the data that already existed at the time of construction.
  - When you add new data to a selection(`mySelection.data(newData)`), the `enter()` and `exit()` functions are not automatically executed again.
  - If you added a behavior to a selection and then add new elements to the selection, you'll have to add the behavior to those new elements again.
  - When a new element is added to a selection, that new node will not be visible if the selection is called upon again later.
    - ```js
      bars
        .data(data, (d) => d.x)
        .enter()
        .each(createBar);
      console.log("old selection", bars); // <-- has no entries
      console.log("fresh selection", svg.selectAll(".bar")); // <-- does have entries
      ```
- As a react-dev, one is used to creating hierarchies of elements a bit like this:
  ```
      node1
          rect
              circle
          text
      node2
          rect
              circle
          text
  ```
  - d3 does not work that way. Instead, it first has you create all rects, then all cirlces, then all texts. Think _layers-of-shapes_, not _hierarchies_.
    ```
        rects
            rect1
            rect2
        circles
            circle1
            circle2
        texts
            text1
            text2
    ```
- Beware of nested `select` statements - each `select` will set the `data` attribute back to the old value
  ```js
  const activeMessages = activeMessageGroup
    .selectAll(".message")
    .data([datum], (d) => d.id);
  const activeMessagesNew = activeMessages.enter();
  const activeMessagesOut = activeMessages.exit();
  activeMessages
    .selectAll("text") // this will go back to the dom and return the existing elements together with their *old* data...
    .data([datum], (d) => d.id) // ...which is why we need to set the new data again.
    .text((n) => {
      return `${n.event.time} -- ${n.event.channel} -- ${n.event.message}`;
    });
  ```

Illustrative example application:

```js
import {
  select,
  create,
  forceCenter,
  forceLink,
  forceManyBody,
  forceSimulation,
  line,
  drag,
  easeBounce,
  event,
} from "d3";

/****************************************************************
 *      Part 0: settings
 ****************************************************************/

const width = 600;
const height = 400;

// Primary color:
const shade0Primary = "#933157"; // = rgb(147, 49, 87) = rgba(147, 49, 87,1) = rgb0(0.576,0.192,0.341)
const shade1Primary = "#E9508B"; // = rgb(233, 80,139) = rgba(233, 80,139,1) = rgb0(0.914,0.314,0.545)
const shade2Primary = "#C54375"; // = rgb(197, 67,117) = rgba(197, 67,117,1) = rgb0(0.773,0.263,0.459)
const shade3Primary = "#612039"; // = rgb( 97, 32, 57) = rgba( 97, 32, 57,1) = rgb0(0.38,0.125,0.224)
const shade4Primary = "#2F0F1B"; // = rgb( 47, 15, 27) = rgba( 47, 15, 27,1) = rgb0(0.184,0.059,0.106)

// Secondary color (1):
const shade0Secondary1 = "#AA5039"; // = rgb(170, 80, 57) = rgba(170, 80, 57,1) = rgb0(0.667,0.314,0.224)
const shade1Secondary1 = "#FF7B58"; // = rgb(255,123, 88) = rgba(255,123, 88,1) = rgb0(1,0.482,0.345)
const shade2Secondary1 = "#E46D4D"; // = rgb(228,109, 77) = rgba(228,109, 77,1) = rgb0(0.894,0.427,0.302)
const shade3Secondary1 = "#703425"; // = rgb(112, 52, 37) = rgba(112, 52, 37,1) = rgb0(0.439,0.204,0.145)
const shade4Secondary1 = "#361911"; // = rgb( 54, 25, 17) = rgba( 54, 25, 17,1) = rgb0(0.212,0.098,0.067)

// Secondary color (2):
const shade0Secondary2 = "#28794C"; // = rgb( 40,121, 76) = rgba( 40,121, 76,1) = rgb0(0.157,0.475,0.298)
const shade1Secondary2 = "#48D083"; // = rgb( 72,208,131) = rgba( 72,208,131,1) = rgb0(0.282,0.816,0.514)
const shade2Secondary2 = "#37A266"; // = rgb( 55,162,102) = rgba( 55,162,102,1) = rgb0(0.216,0.635,0.4)
const shade3Secondary2 = "#1A5032"; // = rgb( 26, 80, 50) = rgba( 26, 80, 50,1) = rgb0(0.102,0.314,0.196)
const shade4Secondary2 = "#0C2718"; // = rgb( 12, 39, 24) = rgba( 12, 39, 24,1) = rgb0(0.047,0.153,0.094)

// Complement color:
const shade0Complement = "#6B9A33"; // = rgb(107,154, 51) = rgba(107,154, 51,1) = rgb0(0.42,0.604,0.2)
const shade1Complement = "#A7F053"; // = rgb(167,240, 83) = rgba(167,240, 83,1) = rgb0(0.655,0.941,0.325)
const shade2Complement = "#8FCF46"; // = rgb(143,207, 70) = rgba(143,207, 70,1) = rgb0(0.561,0.812,0.275)
const shade3Complement = "#466621"; // = rgb( 70,102, 33) = rgba( 70,102, 33,1) = rgb0(0.275,0.4,0.129)
const shade4Complement = "#223110"; // = rgb( 34, 49, 16) = rgba( 34, 49, 16,1) = rgb0(0.133,0.192,0.063)
//  Generated by Paletton.com (c) 2002-2014

/****************************************************************
 *      Part 1: data / state
 ****************************************************************/

let peopleCounter = 0;
let people = [];
let relationCounter = 0;
let relations = [];

/****************************************************************
 *      Part 2: selections
 ****************************************************************/

const base = select("#svg")
  .style("width", width)
  .style("height", height)
  .append("g");

const bubbleSelector = ".bubble";
const lineSelector = ".line";
const dashedLineSelector = ".dashedLine";

const addNodeButton = document.getElementById("addNode");
addNodeButton.addEventListener("click", onAddNodeButtonClicked);

/****************************************************************
 *      Part 3: event handlers
 ****************************************************************/

function onAddNodeButtonClicked() {
  const node = {
    id: peopleCounter,
    x: width * Math.random(),
    y: height * Math.random(),
  };
  peopleCounter += 1;
  people.push(node);

  base
    .selectAll(bubbleSelector)
    .data(people, (d) => d.id)
    .enter()
    .each(createLabeledBubble);
}

const dragBehavior = drag()
  .filter((e) => !e.button)
  .on("start", (e, d) =>
    e.sourceEvent.ctrlKey ? onConnectStart(e, d) : onDragStart(e, d)
  )
  .on("drag", (e, d) =>
    e.sourceEvent.ctrlKey ? onConnect(e, d) : onDrag(e, d)
  )
  .on("end", (e, d) =>
    e.sourceEvent.ctrlKey ? onConnectEnd(e, d) : onDragEnd(e, d)
  );

function onDragStart(evt, datum) {}

function onDrag(evt, datum) {
  people.forEach((p) => {
    if (p.id === datum.id) {
      p.x = evt.x;
      p.y = evt.y;
    }
  });

  base
    .selectAll(bubbleSelector)
    .data(people, (d) => d.id)
    .each(updateLabeledBubble);

  base
    .selectAll(lineSelector)
    .data(relations, (d) => d.id)
    .each(updateConnection);
}

function onDragEnd(evt, datum) {}

function onConnectStart(evt, datum) {
  const d = {
    id: 0,
    source: datum,
    target: {
      x: evt.x,
      y: evt.y,
    },
  };
  base
    .selectAll(dashedLineSelector)
    .data([d], (d) => d.id)
    .enter()
    .each(createDashedLine);
}

function onConnect(evt, datum) {
  const d = {
    id: 0,
    source: datum,
    target: {
      x: evt.x,
      y: evt.y,
    },
  };
  base
    .selectAll(dashedLineSelector)
    .data([d], (d) => d.id)
    .each(updateDashedLine);
}

function onConnectEnd(evt, datum) {
  base
    .selectAll(dashedLineSelector)
    .data([], (d) => d.id)
    .exit()
    .each(removeDashedLine);

  const distances = people.map((p) => distance([evt.x, evt.y], [p.x, p.y]));
  const index = smallest(distances);
  if (distances[index] < 30) {
    const newRelation = {
      id: relationCounter,
      source: datum,
      target: people[index],
    };
    relationCounter += 1;
    relations.push(newRelation);

    base
      .selectAll(lineSelector)
      .data(relations, (d) => d.id)
      .enter()
      .each(createConnection);
  }
}

function onRemoveConnectionClicked(evt, datum) {
  const index = findIndex(relations, (c) => c.id === datum.id);
  relations.splice(index, 1);
  base
    .selectAll(lineSelector)
    .data(relations, (d) => d.id)
    .exit()
    .each(removeConnection);
}

/****************************************************************
 *      Part 4: CRUD components
 ****************************************************************/

function createLabeledBubble(datum, index, nodes) {
  const selection = select(nodes[index]);
  const group = selection
    .append("g")
    .attr("class", bubbleSelector.slice(1))
    .call(dragBehavior)
    .attr("transform", `translate(${datum.x}, ${datum.y})`)
    .on("mouseover", function (evt, datum) {
      select(this).select("circle").attr("fill-opacity", 0.9);
    })
    .on("mouseout", function (evt, datum) {
      select(this).select("circle").attr("fill-opacity", 0.6);
    });
  group
    .append("circle")
    .attr("fill", shade0Primary)
    .attr("fill-opacity", 0.6)
    .attr("stroke", shade3Primary)
    .attr("stroke-width", 1)
    .attr("r", 0)
    .transition()
    .duration(250)
    .ease(easeBounce)
    .attr("r", 10);
  group
    .append("text")
    .attr("fill", "white")
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .text(datum.id);
  //https://stackoverflow.com/questions/5546346/how-to-place-and-center-text-in-an-svg-rectangle
}

function updateLabeledBubble(datum, index, nodes) {
  const selection = select(nodes[index]);
  selection.attr("transform", `translate(${datum.x}, ${datum.y})`);
}

function createDashedLine(datum, index, nodes) {
  const selection = select(nodes[index]);
  selection
    .append("line")
    .attr("class", dashedLineSelector.slice(1))
    .attr("x1", datum.source.x)
    .attr("y1", datum.source.y)
    .attr("x2", datum.target.x)
    .attr("y2", datum.target.y)
    .attr("stroke", shade3Primary)
    .attr("stroke-dasharray", 5)
    .lower();
}

function updateDashedLine(datum, index, nodes) {
  const selection = select(nodes[index]);
  selection.attr("x2", datum.target.x).attr("y2", datum.target.y);
}

function removeDashedLine(datum, index, nodes) {
  const selection = select(nodes[index]);
  selection.remove();
}

function createConnection(datum, index, nodes) {
  const selection = select(nodes[index]);
  const group = selection
    .append("g")
    .attr("class", lineSelector.slice(1))
    .on("mouseover", function (evt, datum) {
      select(this).select("line").attr("stroke-width", 3);
      select(this).select(".close-icon").attr("visibility", "visible");
    })
    .on("mouseout", function (evt, datum) {
      select(this).select("line").attr("stroke-width", 1);
      select(this).select(".close-icon").attr("visibility", "hidden");
    })
    .lower();
  group
    .append("line")
    .attr("x1", datum.source.x)
    .attr("y1", datum.source.y)
    .attr("x2", datum.target.x)
    .attr("y2", datum.target.y)
    .attr("stroke", shade2Secondary2);
  group.append(createCloseButton).attr("visibility", "hidden");
}

function updateConnection(datum, index, nodes) {
  const selection = select(nodes[index]);
  selection
    .select("line")
    .attr("x1", datum.source.x)
    .attr("y1", datum.source.y)
    .attr("x2", datum.target.x)
    .attr("y2", datum.target.y);
  selection
    .select(".close-icon")
    .attr(
      "transform",
      `translate(${(datum.source.x + datum.target.x) / 2}, ${
        (datum.source.y + datum.target.y) / 2
      })`
    );
}

function removeConnection(datum, index, nodes) {
  const selection = select(nodes[index]);
  selection.remove();
}

function createCloseButton(datum, index, nodes) {
  const group = create("svg:g")
    .attr("class", "close-icon")
    .call(dragBehavior)
    .attr(
      "transform",
      `translate(${(datum.source.x + datum.target.x) / 2}, ${
        (datum.source.y + datum.target.y) / 2
      })`
    );
  group
    .append("circle")
    .attr("fill", shade0Complement)
    .attr("fill-opacity", 0.6)
    .attr("stroke", shade3Complement)
    .attr("stroke-width", 1)
    .attr("r", 7);
  group
    .append("text")
    .attr("fill", "white")
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .text("x");
  group.on("click", onRemoveConnectionClicked);
  return group.node();
}

/****************************************************************
 *      Part 5: helpers
 ****************************************************************/

function distance(p1, p2) {
  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
}

function smallest(data) {
  let index = 0;
  let smallest = data[index];
  for (let i = 0; i < data.length; i++) {
    if (data[i] < smallest) {
      index = i;
      smallest = data[index];
    }
  }
  return index;
}

function findIndex(data, predicate) {
  for (let i = 0; i < data.length; i++) {
    if (predicate(data[i])) {
      return i;
    }
  }
}
```

## Enter/Updade/Exit

<img src="https://raw.githubusercontent.com/MichaelLangbein/tdl2/main/backend/data/assets/programming/d3_enter_update_exit.png"  width="200px" style="margin: 3rem;"/>

```html
<html>
  <head>
    <script src="https://d3js.org/d3.v6.js"></script>
  </head>
  <body>
    <h1>Demonstrating the selection, enter & exit flow for animations</h1>

    <ul id="list">
      <li>one</li>
      <li>two</li>
    </ul>

    <p>
      To explore this behavior, call `displayData` a few times from the
      web-console.
    </p>
  </body>
  <script>
    function displayData(data) {
      // step 1: create element- & data-selections (= the blue and the red cirlce)
      const elsNdata = d3
        .select("#list") // selection of parent element
        .selectAll("li") // select all child elements: [li, li]
        .data(data);

      // step 2: handle li's that already have (possibly old) data on them
      elsNdata.text((d) => d);
      // usually, there are initially no pre-defined li's, such that this step is not required.
      // this is good for performance: not handling old items saves on dom-operations.

      // step 3: handle new data points coming in
      elsNdata
        .enter() // all data points that have not yet got an associated li
        .append("li")
        .text((d) => d);

      // step 4: handle old data points going out
      elsNdata
        .exit() // all li's that no longer have data on them
        .remove();
    }

    displayData([1, 2, 3]);
  </script>
</html>
```

```js
    import { select, BaseType, EnterElement, Selection } from 'd3';


    // https://www.youtube.com/watch?v=IyIAR65G-GQ&t=1841s

    interface DataPoint {
        id: number;
        value: number;
    }

    class Queue<T> {
        private data: T[];

        constructor(length: number) {
            this.data = Array(length);
        }

        push(val: T): T {
            this.data.push(val);
            return this.data.shift();
        }

        getData(): T[] {
            return this.data;
        }
    }

    const dataQueue = new Queue<DataPoint>(10);

    let id = 0;
    function addRandomData(queue: Queue<DataPoint>) {
        id += 1;
        queue.push({
            id: id,
            value: Math.random() * 10
        });
    }

    for (let i = 0; i < 10; i++) {
        addRandomData(dataQueue);
    }

    const baseElement: Selection<SVGElement, unknown, HTMLElement, any> = select('#svg')
        .attr('width', 300)
        .attr('height', 300)
        .append('g');

    function update(data: DataPoint[]) {

        // we need to re-select on every update cycle
        const circles: Selection<BaseType, unknown, SVGElement, unknown> = baseElement.selectAll('circle');
        const circlesWithData: Selection<BaseType, DataPoint, SVGElement, unknown> = circles
            .data(data,
                // keyFunction: returns an id for each datum, so that elements know what data they are associated with
                (d: DataPoint, i: number, g: (SVGElement | BaseType)[]) => d.id
            );

        const entering: Selection<EnterElement, DataPoint, SVGElement, unknown> = circlesWithData.enter();
        const updating: Selection<BaseType, DataPoint, SVGElement, unknown> = circlesWithData;
        const enteringAndUpdating = updating.merge(entering);
        const leaving: Selection<BaseType, unknown, SVGElement, unknown> = circlesWithData.exit();
        console.log(`in: ${entering.size()} - update: ${updating.size()} - out: ${leaving.size()}`)

        const entered: Selection<SVGCircleElement, DataPoint, SVGElement, unknown> = entering
            .append('circle')
            .attr('r', 10)
            .attr('cx', (d, i) => i * 20)
            .attr('cy', (d) => 250 - d.value * 10)
            .attr('fill', 'green');

        const updated: Selection<BaseType, DataPoint, SVGElement, unknown> = updating
            .attr('cx', (d, i) => i * 10);

        const removed: Selection<BaseType, unknown, SVGElement, unknown> = leaving.remove();
    }

    const button = document.getElementById('button') as HTMLButtonElement;
    button.addEventListener('click', () => {
        addRandomData(dataQueue);
        const newData = dataQueue.getData();
        update(newData);
    });
```

## Updates

A `Selection`s groups (update, enter and exit) stay the same, even if the data has already been modified.
To get the newer entries in the `update` group, you need to make a new `Selection` using `.selectAll('someTag')`.

## Call vs each

Call is a synonym to `tap`: it allows you to have a side-effect on a selection without breaking the method chain.

```js
selectAll("circle").call(doWithSelection, "red");

function doWithSelection(selection, color) {
  selection.attr("fill", color);
}
```

Note that call is being called _exactly once_. Consider this example:

```js
selectAll("circle")
  .data(someData)
  .enter()
  .append("circle")
  .call(doWithSelection, "red");
```

Here `doWithSelection` is called _only once_ on the whole `selectAll('circle')` selection, not once for each circle.
The reason is that `call` always works on a selection. The enter-method however only returns the enter-property of the last selection.

If you want to have a function called for each datum, use `each` instead.
`each` invokes the specified function for each selected element, in order, being passed the current datum (d), the current index (i), and the current group (nodes), with `this` as the current DOM element (nodes[i]). This method can be used to invoke arbitrary code for each selected element...
Note that you need to `select(this)` first:

```js
const connections = root
  .selectAll("line")
  .data(relations)
  .enter()
  .append((d) => createConnection(d))
  .each(function (datum, i) {
    select(this).style("stroke", "yellow").style("stroke-width", 10);
  });
```

## Modularization: detached elements

Update: detached elements are actually more of a niche case than I thought. More idiomatically, one should probably use `each` instead.

It's actually a little hard to split d3-code into sub-functions. Mostly because it relies so heavily on passing along context using `this`. But there is a way. Note how this requires the use of the `svg` namespace

```js
import {
  select,
  create,
  forceCenter,
  forceLink,
  forceManyBody,
  forceSimulation,
  line,
} from "d3";

/****************************************************************
 *      Part 0: settings
 ****************************************************************/

const width = 600;
const height = 400;

/****************************************************************
 *      Part 1: data
 ****************************************************************/

const people = [
  {
    name: "Andreas",
  },
  {
    name: "Michael",
  },
  {
    name: "Chloe",
  },
  {
    name: "Stefan",
  },
  {
    name: "Eva",
  },
];

const relations = [
  {
    source: people.find((p) => p.name === "Andreas"),
    target: people.find((p) => p.name === "Michael"),
  },
  {
    source: people.find((p) => p.name === "Andreas"),
    target: people.find((p) => p.name === "Chloe"),
  },
  {
    source: people.find((p) => p.name === "Chloe"),
    target: people.find((p) => p.name === "Stefan"),
  },
  {
    source: people.find((p) => p.name === "Michael"),
    target: people.find((p) => p.name === "Eva"),
  },
  {
    source: people.find((p) => p.name === "Michael"),
    target: people.find((p) => p.name === "Chloe"),
  },
];

/****************************************************************
 *      Part 2: layouts
 ****************************************************************/
const simulation = forceSimulation(people)
  .force("charge", forceManyBody().strength(-300))
  .force("center", forceCenter(width / 2, height / 2))
  .force("connection", forceLink(relations))
  .on("tick", tick);

function tick(evt) {
  updateBubbles(bubbles);
  updateConnections(connections);
}

function updateBubbles(bubbles) {
  bubbles.attr("transform", (d, i) => `translate(${d.x}, ${d.y})`);
}

function updateConnections(connections) {
  connections
    .attr("x1", (d) => d.source.x)
    .attr("y1", (d) => d.source.y)
    .attr("x2", (d) => d.target.x)
    .attr("y2", (d) => d.target.y);
}

/****************************************************************
 *      Part 3: components
 ****************************************************************/

function createLabeledCircle(d) {
  const g = create("svg:g");
  g.append("circle")
    .attr("r", 30)
    .attr("fill", "green")
    .attr("outline", "black");
  g.append("text")
    .text(d.name)
    .attr("text-anchor", "middle")
    .attr("x", 50)
    .attr("y", 20);
  return g.node();
}

function createConnection(d) {
  const l = create("svg:line")
    .style("stroke", "black")
    .style("stroke-width", 1);
  return l.node();
}

const svg = select("#graph").attr("width", width).attr("height", height);

const root = svg.append("g");

const bubbles = root
  .selectAll("circle")
  .data(people)
  .enter()
  .append((d) => createLabeledCircle(d));

const connections = root
  .selectAll("line")
  .data(relations)
  .enter()
  .append((d) => createConnection(d));
```

## Generators, components and layouts

The information here stems from [manning](https://livebook.manning.com/book/d3-js-in-action/chapter-5/7).
The three main types of functions in D3 can be classified as generators, components and layouts.

<img src="https://raw.githubusercontent.com/MichaelLangbein/tdl2/main/backend/data/assets/programming/d3_comps_gens_lays.jpg" />

### Layouts

Layout is a way how d3 arranges data for you - commonly in a tree, or a circle-diagram or comparable. In this example below you wrap your data in a `hierarchy` (which, I think, might be a layout itself), then you call a layout-function (like for example `cluster`) on it.

```js
import { select, cluster, curveBundle, lineRadial, dsv, hierarchy } from "d3";

const width = 700;
const height = 500;
const circleRadius = 200;

function findInTree(name, parentGroupName, tree) {
  const parentGroup = tree.children.find((e) => e.name === parentGroupName);
  if (parentGroup) {
    const entry = parentGroup.children.find((e) => e.name === name);
    return entry;
  }
}

function addToTree(name, parentGroupName, tree) {
  const parentGroup = tree.children.find((e) => e.name === parentGroupName);
  parentGroup.children.push({
    name,
    parentGroupName,
    in: [],
    out: [],
  });
}

function findInHierarchy(name, groupName, hierarchy) {
  const group = hierarchy.children.find((c) => c.data.name === groupName);
  if (group) {
    const child = group.children.find((c) => c.data.name === name);
    return child;
  }
}

function parseDataInTree(data) {
  // step 0: base data
  const base = {
    name: "base",
    children: [
      {
        name: "cluster",
        children: [],
      },
      {
        name: "project",
        children: [],
      },
      {
        name: "potential",
        children: [],
      },
      {
        name: "institute",
        children: [],
      },
    ],
  };

  // step 1: hierarchy
  for (let row of data) {
    const institute = row["DLR Institut"];
    if (!findInTree(institute, "institute", base)) {
      addToTree(institute, "institute", base);
    }
    const potential = row["Potential"];
    if (!findInTree(potential, "potential", base)) {
      addToTree(potential, "potential", base);
    }
    const project = row["Projekt"];
    if (!findInTree(project, "project", base)) {
      addToTree(project, "project", base);
    }
    const cluster = row["HumTech Cluster (UNHCR)"];
    if (!findInTree(cluster, "cluster", base)) {
      addToTree(cluster, "cluster", base);
    }
  }
  const hierarchyData = hierarchy(base);

  // step 2: connections at leaf-level
  for (let row of data) {
    const institute = row["DLR Institut"];
    const potential = row["Potential"];
    const project = row["Projekt"];
    const cluster = row["HumTech Cluster (UNHCR)"];

    if (institute && potential) {
      const startNode = findInHierarchy(institute, "institute", hierarchyData);
      const targetNode = findInHierarchy(potential, "potential", hierarchyData);
      startNode.data.out.push(targetNode);
      targetNode.data.in.push(startNode);
    }

    if (institute && project) {
      const startNode = findInHierarchy(institute, "institute", hierarchyData);
      const targetNode = findInHierarchy(project, "project", hierarchyData);
      startNode.data.out.push(targetNode);
      targetNode.data.in.push(startNode);
    }

    if (project && cluster) {
      const startNode = findInHierarchy(project, "project", hierarchyData);
      const targetNode = findInHierarchy(cluster, "cluster", hierarchyData);
      startNode.data.out.push(targetNode);
      targetNode.data.in.push(startNode);
    }

    if (potential && cluster) {
      const startNode = findInHierarchy(potential, "potential", hierarchyData);
      const targetNode = findInHierarchy(cluster, "cluster", hierarchyData);
      startNode.data.out.push(targetNode);
      targetNode.data.in.push(startNode);
    }
  }

  return hierarchyData;
}

function getBubbleColor(d) {
  if (d.depth === 2) {
    switch (d.parent.data.name) {
      case "cluster":
        return "yellow";
      case "project":
        return "blue";
      case "institute":
        return "green";
      case "potential":
        return "red";
    }
  } else if (d.depth === 1) {
    return "black";
  } else {
    return "black";
  }
}

function getPathsFromTree(treeData) {
  const paths = [];

  for (let source of treeData.leaves()) {
    for (let target of source.data.out) {
      const path = source.path(target);
      paths.push(path);
    }
  }

  return paths;
}

function getConnectedPaths(node) {
  const paths = [];
  for (let input of node.data.in) {
    const path = input.path(node);
    paths.push(path);
  }
  for (let output of node.data.out) {
    const path = output.path(node);
    paths.push(path);
  }
  return paths;
}

function getConnectedNodes(node) {
  const nodes = [];
  for (let input of node.data.in) {
    nodes.push(input);
  }
  for (let output of node.data.out) {
    nodes.push(output);
  }
  return nodes;
}

async function main() {
  function highlightConnections(connectedPaths) {
    const highlightedConnections = baseElement
      .selectAll(".highlightedConnection")
      .data(connectedPaths);
    highlightedConnections
      .enter()
      .append("path")
      .attr("class", "highlightedConnection")
      .attr("d", connectionPathFunction)
      .attr("stroke", "black")
      .attr("fill", "none");
    highlightedConnections.exit().remove();
  }

  function highlightNodes(nodes) {
    const highlightedNodes = baseElement
      .selectAll(".highlightedNode")
      .data(nodes);
    highlightedNodes
      .enter()
      .append("circle")
      .attr("class", "highlightedNode")
      .attr("r", 15)
      .attr("transform", (d) => `rotate(${d.x - 90}) translate(${d.y}, 0)`)
      .attr("fill", "black");
    highlightedNodes.exit().remove();
  }

  function onMouseOver(evt, d) {
    const connectedPaths = getConnectedPaths(d);
    const connectedNodes = getConnectedNodes(d);
    highlightConnections(connectedPaths);
    highlightNodes(connectedNodes);
  }

  function onMouseOut(evt, d) {
    highlightConnections([]);
    highlightNodes([]);
  }

  const data = await dsv("|", "./data2.csv");

  const treeData = parseDataInTree(data);
  const pathData = getPathsFromTree(treeData);

  const baseElement = select("#graphic")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("transform", `translate(${width / 2} ${height / 2})`);

  const circlePositioningFunction = cluster().size([360, circleRadius]);
  const treeDataWithPositions = circlePositioningFunction(treeData);
  const leafDataWithPositions = treeDataWithPositions.leaves();

  const connectionPathFunction = lineRadial()
    .curve(curveBundle.beta(0.7))
    .radius((d) => d.y)
    .angle((d) => (d.x / 180) * Math.PI);

  const connections = baseElement
    .selectAll(".connection")
    .data(pathData)
    .enter()
    .append("path")
    .attr("class", "connection")
    .attr("d", connectionPathFunction)
    .attr("stroke", "gray")
    .attr("fill", "none");

  const circles = baseElement
    .selectAll(".bubble")
    .data(leafDataWithPositions)
    .enter()
    .append("circle")
    .attr("class", "bubble")
    .attr("r", 10)
    .attr("fill", (d) => getBubbleColor(d))
    .attr("stroke", "black")
    .attr("transform", (d) => `rotate(${d.x - 90}) translate(${d.y}, 0)`)
    .on("mouseover", onMouseOver)
    .on("mouseout", onMouseOut);
}

main();
```

### Layouts

Layouts don’t draw the data, nor are they called like components or referred to in the drawing code like generators.
Rather, they’re a preprocessing step that formats your data so that it’s ready to be displayed in the form you’ve chosen.
Layouts take a set of input data, apply an algorithm or heuristic,
and output the resulting positions/shapes for a cohesive display of the data.
You can update a layout, and then if you rebind that altered data to your graphical objects, you can use the D3 enter/update/exit syntax to update your layout.

Layouts:

- `Bundle|Bundle-Layout` - apply Holten's hierarchical bundling algorithm to edges.
- `Chord|Chord-Layout` - produce a chord diagram from a matrix of relationships.
- `Cluster|Cluster-Layout` - cluster entities into a dendrogram.
- `Force|Force-Layout` - position linked nodes using physical simulation.
- `Hierarchy|Hierarchy-Layout` - derive a custom hierarchical layout implementation.
- `Histogram|Histogram-Layout` - compute the distribution of data using quantized bins.
- `Pack|Pack-Layout` - produce a hierarchical layout using recursive circle-packing.
- `Partition|Partition-Layout` - recursively partition a node tree into a sunburst or icicle.
- `Pie|Pie-Layout` - compute the start and end angles for arcs in a pie or donut chart.
- `Stack|Stack-Layout` - compute the baseline for each series in a stacked bar or area chart.
- `Tree|Tree-Layout` - position a tree of nodes tidily.
- `Treemap|Treemap-Layout` - use recursive spatial subdivision to display a tree of nodes.

Some layouts are even dynamic through time: for example, you `start()` a `d3.layout.force()` instance and then listen for layout updates on 'tick' events.
These are called `simulations`. The `forceSimulation` is certainly one of the most prominent members of these layouts.

#### Custom layouts

Creating a custom layout is easy. Really it's just a function that add's some position-data to the given set of data-points.

```js
function myLayout() {
  var space = 1;
  function compute(data) {
    // same as before
  }
  compute.space = function (s) {
    if (!arguments.length) return space;
    space = s;
    return this; // chaining
  };
  return compute;
}
var layout = myLayout().space(10);
var nodes = layout(myData);
```

### Generators

Contrary to layouts, generators work on single data-points. They don't modify the data-points, either,
but use their (x- and y-)properties for drawing. (In the case of svg's, that drawing consists of simply returning a `svg.d` path string.)

- `d3.line`: Generates path data for a multi-segment line (typically for line charts)
- `d3.area`: Generates path data for an area (typically for stacked line charts and stream-graphs)
- `d3.stack`: Generates stack data from multi-series data
- `d3.arc`: Generates path data for an arc (typically for pie charts)
- `d3.pie`: Generates pie angle data from array of data
- `d3.symbol`: Generates path data for symbols such as plus, star, diamond

#### Custom generators

You can create your own generators like so:

```js
This is certainly possible, you would need to create this generator from scratch, i.e.:

function circleGen() {
  //set defaults
  var r = function(d) { return d.radius; },
      x = function(d) { return d.x; },
      y = function(d) { return d.y; };

  //returned function to generate circle path
  function circle(d) {
    var cx = d3.functor(x).call(this, d),
        cy = d3.functor(y).call(this, d),
        myr = d3.functor(r).call(this, d);

    return "M" + cx + "," + cy + " " +
           "m" + -myr + ", 0 " +
           "a" + myr + "," + myr + " 0 1,0 " + myr*2  + ",0 " +
           "a" + myr + "," + myr + " 0 1,0 " + -myr*2 + ",0Z";
  }

  //getter-setter methods
  circle.r = function(value) {
    if (!arguments.length) return r; r = value; return circle;
  };
  circle.x = function(value) {
    if (!arguments.length) return x; x = value; return circle;
  };
  circle.y = function(value) {
    if (!arguments.length) return y; y = value; return circle;
  };

  return circle;
}
```

And use it like so:

```js
var myC = circleGen()
  .x(function (d) {
    return d.x;
  })
  .y(function (d) {
    return d.y;
  })
  .r(function (d) {
    return d.r;
  });

var data = [
  { x: 150, y: 100, r: 10, fill: "green" },
  { x: 200, y: 150, r: 5, fill: "red" },
  { x: 100, y: 250, r: 25, fill: "blue" },
];

svg
  .selectAll("path.circle")
  .data(data)
  .enter()
  .append("path")
  .attr("class", "circle")
  .attr("d", myC)
  .style("fill", function (d) {
    return d.fill;
  });
```

### Components

In contrast with generators, which produce the d attribute string necessary for a `<path>` element, components create an entire set of graphical objects necessary for a particular chart component. The most commonly used D3 component (which you’ll see in this chapter) is d3.svg.axis, which creates a bunch of `<line>`, `<path>`, `<g>`, and `<text>` elements that are needed for an axis based on the scale and settings you provide the function.

#### Custom components

Components are always functions that take a `selection` as their only argument and return `this`.

```js
function myComponent(selection) {
    selection.append(<... something to append ...>);
    return this;
}
```

Commonly components are provided inside closures so that the user can append options.

```js
function linearGradientComponent(gradientName) {
  let _stops = [];

  function _getOrAddDefs(selection) {
    let defs = selection.select("defs");
    if (!defs.node()) defs = selection.append("defs");
    return defs;
  }

  function _getOrAddGrad(defsSelection) {
    let grad = defsSelection.select(`#${gradientName}`);
    if (!grad.node()) {
      grad = defsSelection
        .append("linearGradient")
        .attr("id", gradientName)
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "100%")
        .attr("y2", "0%"); // horizontal
    }
    return grad;
  }

  function gradient(selection) {
    const defs = _getOrAddDefs(selection);
    const gradient = _getOrAddGrad(defs);
    gradient
      .selectAll("stop")
      .data(_stops)
      .enter()
      .append("stop")
      .attr("offset", (d) => `${d.offset}%`)
      .attr(
        "style",
        (d) =>
          `stop-color:rgb(${d.color[0]}, ${d.color[1]}, ${d.color[2]}); stop-opacity:${d.opacity}`
      );
  }

  gradient.stops = (stops) => {
    _stops = stops;
    return this;
  };

  return gradient;
}

const myLinearGradient = linearGradientComponent("myGradient");
myLinearGradient.stops([
  { offset: 0, color: [183, 230, 88], opacity: 1 },
  { offset: 100, color: [221, 152, 42], opacity: 1 },
]);

const testSvg = select("#testSvg");
testSvg.call(myLinearGradient);
testSvg
  .append("rect")
  .attr("width", 100)
  .attr("height", 30)
  .attr("fill", `url(#myGradient)`);
```

An even more extensive example of a component:

````js
import { color, hsl } from "d3-color";
import { scaleLinear } from "d3-scale";

function linearGradientComponent(gradientName: string) {
  let _stops = [];
  let _name = gradientName;
  let _direction = "horizontal";

  function _getOrAddDefs(selection) {
    let defs = selection.select("defs");
    if (!defs.node()) defs = selection.append("defs");
    return defs;
  }

  function _getOrAddGrad(defsSelection) {
    let grad = defsSelection.select(`#${_name}`);
    if (!grad.node()) {
      grad = defsSelection.append("linearGradient").attr("id", _name);
      if (_direction === "horizontal") {
        grad
          .attr("x1", "0%")
          .attr("y1", "0%")
          .attr("x2", "100%")
          .attr("y2", "0%");
      } else if (_direction === "vertical") {
        grad
          .attr("x1", "0%")
          .attr("y1", "0%")
          .attr("x2", "0%")
          .attr("y2", "100%");
      }
    }
    return grad;
  }

  function gradient(selection) {
    const defs = _getOrAddDefs(selection);
    const gradient = _getOrAddGrad(defs);
    gradient
      .selectAll("stop")
      .data(_stops)
      .enter()
      .append("stop")
      .attr("offset", (d) => `${d.offset}%`)
      .attr(
        "style",
        (d) =>
          `stop-color:rgb(${color(d.color).r}, ${color(d.color).g}, ${
            color(d.color).b
          }); stop-opacity:${d.opacity}`
      );
  }

  gradient.stops = (stops) => {
    _stops = stops;
    return gradient;
  };
  gradient.gradId = (name) => {
    _name = name;
    return gradient;
  };
  gradient.direction = (direction) => {
    _direction = direction;
    return gradient;
  };

  return gradient;
}

function scaleColor() {
  // default parameters
  let _domain = [0, 1];
  let _range = ["rgb(255, 0, 0)", "rgb(0, 0, 255)"];

  // actual interpolation
  function interpolate(rStart, rEnd, rel) {
    const cStart = color(rStart);
    const cEnd = color(rEnd);
    const cStartHSL = hsl(cStart);
    const cEndHSL = hsl(cEnd);
    const hInterp = cStartHSL.h + rel * (cEndHSL.h - cStartHSL.h);
    const sInterp = cStartHSL.s + rel * (cEndHSL.s - cStartHSL.s);
    const lInterp = cStartHSL.l + rel * (cEndHSL.l - cStartHSL.l);
    const interpHSL = hsl(hInterp, sInterp, lInterp);
    return interpHSL.rgb().toString();
  }

  // deciding which colors to interpolate between
  function scale(d) {
    for (let i = 0; i < _domain.length; i++) {
      const dStart = _domain[i];
      const dEnd = _domain[i + 1];
      if (d < dStart) {
        return _range[0];
      }
      if (dStart <= d && d < dEnd) {
        const rStart = _range[i];
        const rEnd = _range[i + 1];
        const rel = (d - dStart) / (dEnd - dStart);
        return interpolate(rStart, rEnd, rel);
      }
      if (dEnd < d) {
        return _range[_range.length - 1];
      }
    }
  }

  // public methods
  scale.domain = function (d) {
    _domain = d;
    return scale;
  };
  scale.range = function (r) {
    _range = r;
    return scale;
  };

  return scale;
}

export interface LegendEntryDiscrete {
  size: number;
  color: string;
  text: string;
}

function createLegendDiscrete(
  svgSelection,
  id: string,
  width: number,
  height: number,
  direction: LegendDirection,
  entries: LegendEntryDiscrete[],
  fractionGraphic: number = 0.5,
  margin: number = 10
) {
  // layouting
  const dominantSize = direction === "horizontal" ? width : height;

  const layoutEntries: any[] = [];
  let wSum = 0.0;
  for (const entry of entries) {
    layoutEntries.push({
      ...entry,
      startPos: wSum,
      textPos: wSum + entry.size / 2.0,
      endPos: wSum + entry.size,
      scaledSize: entry.size,
    });
    wSum += entry.size;
  }
  for (const entry of layoutEntries) {
    entry.startPos *= dominantSize / wSum;
    entry.textPos *= dominantSize / wSum;
    entry.endPos *= dominantSize / wSum;
    entry.scaledSize *= dominantSize / wSum;
  }

  const bandWidth = dominantSize / entries.length;
  const graphicWidth =
    direction === "horizontal" ? width : fractionGraphic * width;
  const graphicHeight =
    direction === "horizontal" ? fractionGraphic * height : height;
  const graphicEntryWidth =
    direction === "horizontal" ? bandWidth : fractionGraphic * width;
  const graphicEntryHeight =
    direction === "horizontal" ? fractionGraphic * height : bandWidth;

  // appending legend to selection

  const legendGroup = svgSelection
    .attr("width", width + 2 * margin)
    .attr("height", height + 2 * margin)
    .append("g")
    .attr("transform", `translate(${margin}, ${margin})`)
    .attr("class", "legendGroup");

  const graphic = legendGroup
    .selectAll(".legendRect")
    .data(layoutEntries)
    .enter()
    .append("g")
    .attr("class", "legendRect")
    .attr("transform", (d) =>
      direction === "horizontal"
        ? `translate(${d.startPos}, 0)`
        : `translate(0, ${d.startPos})`
    )
    .append("rect")
    .attr("width", (d) =>
      direction === "horizontal" ? d.scaledSize : graphicEntryWidth
    )
    .attr("height", (d) =>
      direction === "horizontal" ? graphicEntryHeight : d.scaledSize
    )
    .attr("fill", (d) => d.color);

  const labels = legendGroup
    .selectAll(".label")
    .data(layoutEntries)
    .enter()
    .append("g")
    .attr("class", "label")
    .attr("transform", (d) =>
      direction === "horizontal"
        ? `translate(${d.textPos}, ${graphicHeight + 10})`
        : `translate(${graphicWidth + 10}, ${d.textPos})`
    )
    .append("text")
    .text((d) => d.text)
    .style("text-anchor", direction === "horizontal" ? "middle" : "left")
    .style("dominant-baseline", "central");
}

export interface LegendEntryContinuous {
  position: number;
  color: string;
  text: string;
}

export type LegendDirection = "horizontal" | "vertical";

function createLegendContinuous(
  svgSelection,
  id: string,
  width: number,
  height: number,
  direction: LegendDirection,
  entries: LegendEntryContinuous[],
  fractionGraphic: number = 0.5,
  margin: number = 10
) {
  // layouting
  const dominantSize = direction === "horizontal" ? width : height;
  const minPos = Math.min(...entries.map((e) => e.position));
  const maxPos = Math.max(...entries.map((e) => e.position));

  const placementScale = scaleLinear()
    .domain([minPos, maxPos])
    .range([0, dominantSize]);

  const percentageScale = scaleLinear()
    .domain([minPos, maxPos])
    .range([0, 100]);

  const colorScale = scaleColor();
  colorScale
    .domain(entries.map((e) => e.position))
    .range(entries.map((e) => e.color));

  const graphicWidth =
    direction === "horizontal" ? width : fractionGraphic * width;
  const graphicHeight =
    direction === "horizontal" ? fractionGraphic * height : height;

  // appending legend to selection

  const legendGroup = svgSelection
    .attr("width", width + 2 * margin)
    .attr("height", height + 2 * margin)
    .append("g")
    .attr("transform", `translate(${margin}, ${margin})`)
    .attr("class", "legendGroup");

  const legendGradient = linearGradientComponent(id)
    .direction(direction)
    .stops(
      entries.map((e) => ({
        offset: percentageScale(e.position),
        color: colorScale(e.position),
        opacity: 1,
      }))
    );

  svgSelection.call(legendGradient);

  const graphic = legendGroup
    .append("rect")
    .attr("class", "graphic")
    .attr("width", graphicWidth)
    .attr("height", graphicHeight)
    .attr("fill", `url(#${id})`);

  const labels = legendGroup
    .selectAll(".label")
    .data(entries)
    .enter()
    .append("g")
    .attr("class", "label")
    .attr("transform", (d) =>
      direction === "horizontal"
        ? `translate(${placementScale(d.position)}, ${graphicHeight + 10})`
        : `translate(${graphicWidth + 10}, ${placementScale(d.position)})`
    )
    .append("text")
    .text((d) => d.text)
    .style("text-anchor", direction === "horizontal" ? "middle" : "left")
    .style("dominant-baseline", "middle");
}

export type LegendEntry = {
  color: string,
  text: string,
  position?: number,
  size?: number,
};

/**
 * ## Legend component
 * When applied to a d3-selection, adds a legend to it.
 * 
 * ## Example usage
 * 
    ```js
    const entries: Entry[] = [{
    color: 'rgb(255, 0, 0)',
    text: 'red',
    position: 0.0  // position: legend infers that it must be continuous.
                   // for a discrete legend, use `size`
    }, {
    color: 'rgb(0, 255, 0)',
    text: 'green',
    position: 0.5
    }, {
    color: 'rgb(0, 0, 255)',
    text: 'blue',
    position: 1.0
    }];

    const base = select('app');
    const svg = base.append('svg');
    const legend = legendComponent()
      .id('mylegend')
      .width(300).height(50).direction('horizontal')
      .fractionGraphic(0.4)   // how much of the secondary direction should be taken up by graphic (vs labels)=
      .margin(5)
      .entries(entries);
    ```
 * 
 */
export function legendComponent() {
  let _id = "myLegendGradient";
  let _width = 300;
  let _height = 100;
  let _direction: LegendDirection = "horizontal";
  let _fractionGraphic = 0.5;
  let _continuous = false;
  let _margin = 10;
  let _entries: LegendEntry[] = [];

  function legend(selection) {
    if (_continuous) {
      let p = 0;
      const delta = Math.max(_width, _height) / _entries.length;
      const entries: LegendEntryContinuous[] = [];
      for (const entry of _entries) {
        const pos = entry.position ?? p;
        entries.push({
          color: entry.color,
          text: entry.text,
          position: pos,
        });
        p += delta;
      }
      createLegendContinuous(
        selection,
        _id,
        _width,
        _height,
        _direction,
        entries,
        _fractionGraphic,
        _margin
      );
    } else {
      const entries: LegendEntryDiscrete[] = [];
      for (const entry of _entries) {
        const size = entry.size ?? 1;
        entries.push({
          color: entry.color,
          text: entry.text,
          size: size,
        });
      }
      createLegendDiscrete(
        selection,
        _id,
        _width,
        _height,
        _direction,
        entries,
        _fractionGraphic,
        _margin
      );
    }
  }

  legend.id = (id: string) => {
    _id = id;
    return legend;
  };
  legend.width = (width: number) => {
    _width = width;
    return legend;
  };
  legend.height = (height: number) => {
    _height = height;
    return legend;
  };
  legend.fractionGraphic = (fractionGraphic: number) => {
    _fractionGraphic = fractionGraphic;
    return legend;
  };
  legend.margin = (margin: number) => {
    _margin = margin;
    return legend;
  };
  legend.direction = (direction: LegendDirection) => {
    _direction = direction;
    return legend;
  };
  legend.continuous = (continuous: boolean) => {
    _continuous = continuous;
    return legend;
  };
  legend.entries = (entries: LegendEntry[]) => {
    _entries = entries;
    return legend;
  };

  return legend;
}
````

## Range & scale

Scales are a type of layout.

- `scaleSequential`:
- `scaleOrdinal`: Domain: a categorical list.
- `scaleBand`: used for bar-chats and the like. Domain: a categorical list.

### Custom scale

```js
const entries = [
  {
    color: "rgb(255, 0, 0)",
    text: "red",
    position: 0.0,
  },
  {
    color: "rgb(0, 255, 0)",
    text: "green",
    position: 0.5,
  },
  {
    color: "rgb(0, 0, 255)",
    text: "blue",
    position: 1.0,
  },
];

function scaleColor() {
  // default parameters
  let _domain = [0, 1];
  let _range = ["rgb(255, 0, 0)", "rgb(0, 0, 255)"];

  // actual interpolation
  function interpolate(rStart, rEnd, rel) {
    const cStart = color(rStart);
    const cEnd = color(rEnd);
    const cStartHSL = hsl(cStart);
    const cEndHSL = hsl(cEnd);
    const hInterp = cStartHSL.h + rel * (cEndHSL.h - cStartHSL.h);
    const sInterp = cStartHSL.s + rel * (cEndHSL.s - cStartHSL.s);
    const lInterp = cStartHSL.l + rel * (cEndHSL.l - cStartHSL.l);
    const interpHSL = hsl(hInterp, sInterp, lInterp);
    return interpHSL.rgb().toString();
  }

  // deciding which colors to interpolate between
  function scale(d) {
    for (let i = 0; i < _domain.length; i++) {
      const dStart = _domain[i];
      const dEnd = _domain[i + 1];
      if (d < dStart) {
        return _range[0];
      }
      if (dStart <= d && d < dEnd) {
        const rStart = _range[i];
        const rEnd = _range[i + 1];
        const rel = (d - dStart) / (dEnd - dStart);
        return interpolate(rStart, rEnd, rel);
      }
      if (dEnd < d) {
        return _range[_range.length - 1];
      }
    }
  }

  // public methods
  scale.domain = function (d) {
    _domain = d;
    return scale;
  };
  scale.range = function (r) {
    _range = r;
    return scale;
  };

  return scale;
}

const colorScale = scaleColor()
  .domain(entries.map((e) => e.position))
  .range(entries.map((e) => e.color));
```

## Behaviors

Behaviors are event systems. They expose a few `on` events and are added onto a selection using `selection.call(behavior)`
Common behaviors:

- zoom: exposes `zoom` event
- drag: exposes `start`, `drag`, `end` events

## Force

One of the hardest parts of d3 is the usage of force in combination with drag.

```js
    import { BaseType, forceCenter, forceLink, forceManyBody, select, Selection } from "d3";
import { forceSimulation, SimulationLinkDatum, SimulationNodeDatum } from "d3-force";
import { drag } from 'd3-drag';

/**
Each node must be an object. The following properties are assigned by the simulation:

index: the node's zero-based index into nodes
x - the node's current x-position
y - the node's current y-position
vx - the node's current x-velocity
vy - the node's current y-velocity

The position (x, y) and velocity (vx, vy) may be subsequently modified by forces and by the simulation.
If either vx or vy is NaN, the velocity is initialized to (0, 0). If either x or y is NaN,
the position is initialized in a phyllotaxis arrangement, so chosen to ensure a deterministic, uniform distribution.

Each link is an object with the following properties:

source - the link's source node; see simulation.nodes
target - the link's target node; see simulation.nodes
 */

interface Institute extends SimulationNodeDatum {
    id: string;
}

const institutes: Institute[] = [{
    id: 'finance'
}, {
    id: 'spaceflight'
}, {
    id: 'research'
}];

const links: SimulationLinkDatum<Institute>[] = [{
    source: institutes.find(i => i.id === 'spaceflight'),
    target: institutes.find(i => i.id === 'finance')
}, {
    source: institutes.find(i => i.id === 'spaceflight'),
    target: institutes.find(i => i.id === 'research')
}];




const simulation = forceSimulation(institutes)
    .force("charge", forceManyBody().strength(-30))
    .force("link", forceLink(links))
    .force("center", forceCenter().x(150).y(150))
    .on('tick', simulationTick);

const dragCallback = drag()
    .on('start', (evt: DragEvent, d: Institute) => {
        simulation.alphaTarget(0.3).restart();
    })
    .on('drag', (evt, d: Institute) => {
        d.fx = evt.x;
        d.fy = evt.y;
    })
    .on('end', (evt: DragEvent, d: Institute) => {
        simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    });


const rootElement = select('#svg')
    .attr('width', 500)
    .attr('height', 300)
    .append('g');

rootElement.selectAll('circle')
    .data(institutes)
    .enter()
        .append('circle')
        .attr('r', 10)
    .call(dragCallback);

rootElement.selectAll('line')
    .data(links)
    .enter()
        .append('line')
        .attr('stroke', 'black')
        .attr('stroke-width', 2);

function simulationTick() {
    rootElement.selectAll('circle')
        .attr('cx', d => (d as Institute).x)
        .attr('cy', d => (d as Institute).y);

    rootElement.selectAll('line')
        .attr('x1', d => ((d as SimulationLinkDatum<Institute>).source as Institute).x)
        .attr('y1', d => ((d as SimulationLinkDatum<Institute>).source as Institute).y)
        .attr('x2', d => ((d as SimulationLinkDatum<Institute>).target as Institute).x)
        .attr('y2', d => ((d as SimulationLinkDatum<Institute>).target as Institute).y);
}
```
